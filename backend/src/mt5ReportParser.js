/**
 * MT5 HTML Report Parser
 * Parses HTML reports generated by MetaTrader 5 Strategy Tester
 */

export function parseMT5Report(htmlContent) {
  try {
    // Extract key metrics using regex patterns
    const metrics = {
      // Basic Info
      symbol: extractValue(htmlContent, /<td[^>]*>Symbol<\/td>\s*<td[^>]*>(.*?)<\/td>/i),
      period: extractValue(htmlContent, /<td[^>]*>Period<\/td>\s*<td[^>]*>(.*?)<\/td>/i),
      model: extractValue(htmlContent, /<td[^>]*>Model<\/td>\s*<td[^>]*>(.*?)<\/td>/i),

      // Date Range
      startDate: extractValue(htmlContent, /<td[^>]*>(?:Initial deposit|Testing period)<\/td>\s*<td[^>]*>(.*?)\s*-/i),
      endDate: extractValue(htmlContent, /<td[^>]*>(?:Initial deposit|Testing period)<\/td>\s*<td[^>]*>.*?\s*-\s*(.*?)<\/td>/i),

      // Account Metrics
      initialDeposit: parseFloat(extractValue(htmlContent, /<td[^>]*>Initial deposit<\/td>\s*<td[^>]*>([\d\s.]+)/i) || '0'),
      totalNetProfit: parseFloat(extractValue(htmlContent, /<td[^>]*>Total net profit<\/td>\s*<td[^>]*>([-\d\s.]+)/i) || '0'),
      grossProfit: parseFloat(extractValue(htmlContent, /<td[^>]*>Gross profit<\/td>\s*<td[^>]*>([\d\s.]+)/i) || '0'),
      grossLoss: parseFloat(extractValue(htmlContent, /<td[^>]*>Gross loss<\/td>\s*<td[^>]*>([-\d\s.]+)/i) || '0'),
      profitFactor: parseFloat(extractValue(htmlContent, /<td[^>]*>Profit factor<\/td>\s*<td[^>]*>([\d.]+)/i) || '0'),

      // Drawdown
      maximalDrawdown: parseFloat(extractValue(htmlContent, /<td[^>]*>Maximal drawdown<\/td>\s*<td[^>]*>([\d\s.]+)/i) || '0'),
      maximalDrawdownPercent: parseFloat(extractValue(htmlContent, /<td[^>]*>Maximal drawdown<\/td>\s*<td[^>]*>[\d\s.]+\s*\(([\d.]+)%\)/i) || '0'),
      relativeDrawdown: parseFloat(extractValue(htmlContent, /<td[^>]*>Relative drawdown<\/td>\s*<td[^>]*>([\d.]+)%/i) || '0'),

      // Trade Statistics
      totalTrades: parseInt(extractValue(htmlContent, /<td[^>]*>Total (?:deals|trades)<\/td>\s*<td[^>]*>(\d+)/i) || '0'),
      shortPositions: parseInt(extractValue(htmlContent, /<td[^>]*>Short positions[^<]*<\/td>\s*<td[^>]*>(\d+)/i) || '0'),
      longPositions: parseInt(extractValue(htmlContent, /<td[^>]*>Long positions[^<]*<\/td>\s*<td[^>]*>(\d+)/i) || '0'),

      // Win Rate
      profitTrades: parseInt(extractValue(htmlContent, /<td[^>]*>Profit (?:deals|trades)[^<]*<\/td>\s*<td[^>]*>(\d+)/i) || '0'),
      lossTrades: parseInt(extractValue(htmlContent, /<td[^>]*>Loss (?:deals|trades)[^<]*<\/td>\s*<td[^>]*>(\d+)/i) || '0'),

      // Averages
      largestProfitTrade: parseFloat(extractValue(htmlContent, /<td[^>]*>Largest profit trade<\/td>\s*<td[^>]*>([\d\s.]+)/i) || '0'),
      largestLossTrade: parseFloat(extractValue(htmlContent, /<td[^>]*>Largest loss trade<\/td>\s*<td[^>]*>([-\d\s.]+)/i) || '0'),
      averageProfitTrade: parseFloat(extractValue(htmlContent, /<td[^>]*>Average profit trade<\/td>\s*<td[^>]*>([\d\s.]+)/i) || '0'),
      averageLossTrade: parseFloat(extractValue(htmlContent, /<td[^>]*>Average loss trade<\/td>\s*<td[^>]*>([-\d\s.]+)/i) || '0'),

      // Consecutive
      maxConsecutiveWins: parseInt(extractValue(htmlContent, /<td[^>]*>Maximum consecutive wins[^<]*<\/td>\s*<td[^>]*>(\d+)/i) || '0'),
      maxConsecutiveLosses: parseInt(extractValue(htmlContent, /<td[^>]*>Maximum consecutive losses[^<]*<\/td>\s*<td[^>]*>(\d+)/i) || '0'),
      maxConsecutiveProfit: parseFloat(extractValue(htmlContent, /<td[^>]*>Maximal consecutive profit[^<]*<\/td>\s*<td[^>]*>([\d\s.]+)/i) || '0'),
      maxConsecutiveLoss: parseFloat(extractValue(htmlContent, /<td[^>]*>Maximal consecutive loss[^<]*<\/td>\s*<td[^>]*>([-\d\s.]+)/i) || '0'),

      // Recovery Factor & Sharpe
      recoveryFactor: parseFloat(extractValue(htmlContent, /<td[^>]*>Recovery factor<\/td>\s*<td[^>]*>([\d.]+)/i) || '0'),
      sharpeRatio: parseFloat(extractValue(htmlContent, /<td[^>]*>Sharpe Ratio<\/td>\s*<td[^>]*>([-\d.]+)/i) || '0'),

      // Balance
      balance: parseFloat(extractValue(htmlContent, /<td[^>]*>Balance<\/td>\s*<td[^>]*>([\d\s.]+)/i) || '0'),
      equity: parseFloat(extractValue(htmlContent, /<td[^>]*>Equity<\/td>\s*<td[^>]*>([\d\s.]+)/i) || '0')
    };

    // Calculate derived metrics
    metrics.winRate = metrics.totalTrades > 0
      ? ((metrics.profitTrades / metrics.totalTrades) * 100).toFixed(2)
      : 0;

    metrics.lossRate = metrics.totalTrades > 0
      ? ((metrics.lossTrades / metrics.totalTrades) * 100).toFixed(2)
      : 0;

    metrics.returnOnInvestment = metrics.initialDeposit > 0
      ? ((metrics.totalNetProfit / metrics.initialDeposit) * 100).toFixed(2)
      : 0;

    // Extract trade list from HTML table
    const trades = extractTrades(htmlContent);

    return {
      success: true,
      metrics,
      trades,
      totalTrades: trades.length
    };
  } catch (error) {
    console.error('Error parsing MT5 report:', error);
    return {
      success: false,
      error: 'Failed to parse MT5 report: ' + error.message
    };
  }
}

/**
 * Extract value using regex pattern
 */
function extractValue(html, pattern) {
  const match = html.match(pattern);
  return match ? match[1].trim().replace(/\s+/g, '') : null;
}

/**
 * Extract individual trades from the HTML report
 */
function extractTrades(htmlContent) {
  const trades = [];

  try {
    // Find the trades/deals table
    // MT5 reports typically have a table with class="trades" or similar
    const tableRegex = /<table[^>]*class=["']?(?:deals|trades)["']?[^>]*>(.*?)<\/table>/is;
    const tableMatch = htmlContent.match(tableRegex);

    if (!tableMatch) {
      // Try alternate pattern - find any table after "History" text
      const historyRegex = /History.*?<table[^>]*>(.*?)<\/table>/is;
      const historyMatch = htmlContent.match(historyRegex);

      if (historyMatch) {
        return parseTradeRows(historyMatch[1]);
      }
      return [];
    }

    return parseTradeRows(tableMatch[1]);
  } catch (error) {
    console.error('Error extracting trades:', error);
    return [];
  }
}

/**
 * Parse trade rows from table HTML
 */
function parseTradeRows(tableHTML) {
  const trades = [];
  const rowRegex = /<tr[^>]*>(.*?)<\/tr>/gis;
  const rows = [...tableHTML.matchAll(rowRegex)];

  // Skip header row
  for (let i = 1; i < rows.length; i++) {
    const cells = extractCells(rows[i][1]);

    if (cells.length >= 6) {
      const trade = {
        ticket: cells[0] || '',
        time: cells[1] || '',
        type: cells[2] || '',
        volume: parseFloat(cells[3]) || 0,
        price: parseFloat(cells[4]) || 0,
        sl: parseFloat(cells[5]) || 0,
        tp: parseFloat(cells[6]) || 0,
        profit: parseFloat(cells[8]) || 0,
        balance: parseFloat(cells[9]) || 0
      };

      trades.push(trade);
    }
  }

  return trades;
}

/**
 * Extract cell values from table row
 */
function extractCells(rowHTML) {
  const cellRegex = /<t[dh][^>]*>(.*?)<\/t[dh]>/gi;
  const cells = [...rowHTML.matchAll(cellRegex)];
  return cells.map(cell => cell[1].trim().replace(/<[^>]*>/g, ''));
}

/**
 * Validate MT5 report HTML
 */
export function validateMT5Report(htmlContent) {
  // Check for key indicators that this is an MT5 report
  const indicators = [
    /MetaTrader/i,
    /Strategy Tester/i,
    /Total net profit/i,
    /Profit factor/i,
    /Initial deposit/i
  ];

  const validCount = indicators.filter(pattern => pattern.test(htmlContent)).length;

  return {
    isValid: validCount >= 3,
    confidence: (validCount / indicators.length) * 100
  };
}
